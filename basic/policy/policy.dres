# -*-makefile-*-
PREFIX = com.nokia.policy

# resource
$resource_owner  = {resource: rear_flashlight, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner  = {resource: headset_buttons, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: lens_cover,      owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: snap_button,     owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: scale_button,    owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: lock_button,     owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: system_button,   owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: backlight,       owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: leds,            owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: vibra,           owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: video_recording, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: audio_recording, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: video_playback , owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: audio_playback , owner: nobody, mode: shared, \
                    group   : nobody }

$audio_resource_owner = { previous: nobody, current: nobody }
$active_audio_manager_id = { id: 0 }
$active_audio_manager = { previous: 0, current: 0 }
$call_start_privacy = { value: none }
$ignore_privacy_change = { value: 0 }

$resource_set = {manager_id:0, client_pid:0, client_name:dres, client_id:0, app_id:internal, class:fake,    \
                 mode:0, mandatory:0, optional:0, shared:0, mask:0, granted:0,\
                 advice:0, request:release, block:0, reqno:0, audiogr:fake, videopid:0}


# video devices
$video_device_accessible  = { name: tvout                   , connected: 0 }
$video_device_accessible += { name: builtin                 , connected: 1 }

$video_device_selectable  = { name: builtinandtvout         , selectable: 0 }
$video_device_selectable += { name: tvout                   , selectable: 0 }
$video_device_selectable += { name: builtin                 , selectable: 1 }

# video routing
$video_route = { device: builtin, tvstandard: pal, aspectratio: normal }

# audio devices
$audio_device_accessible  = { name: null                    , driver: 1, connected: 1 }
$audio_device_accessible += { name: nullsource              , driver: 0, connected: 1 }
$audio_device_accessible += { name: ihf                     , driver: 1, connected: 1 }
$audio_device_accessible += { name: microphone              , driver: 1, connected: 1 }
$audio_device_accessible += { name: backmicrophone          , driver: 1, connected: 1 }
$audio_device_accessible += { name: earpiece                , driver: 0, connected: 1 }
$audio_device_accessible += { name: tvout                   , driver: 1, connected: 0 }
$audio_device_accessible += { name: headmike                , driver: 1, connected: 0 }
$audio_device_accessible += { name: headphone               , driver: 1, connected: 0 }
$audio_device_accessible += { name: lineout                 , driver: 1, connected: 0 }
$audio_device_accessible += { name: headset                 , driver: 1, connected: 0 }
$audio_device_accessible += { name: bthfp                   , driver: 0, connected: 0 }
$audio_device_accessible += { name: bthsp                   , driver: 0, connected: 0 }
$audio_device_accessible += { name: bta2dp                  , driver: 0, connected: 0 }
# We consider the usb audio devices to be always connected, as the driver and
# selectable are updated when the interface appears.
# We will never route to usb audio unless the device is selectable, so this
# shouldn't cause any problems.
$audio_device_accessible += { name: usbaudio                , driver: 0, connected: 1 }
$audio_device_accessible += { name: usbmic                  , driver: 0, connected: 1 }
$audio_device_accessible += { name: fmradioloopback         , driver: 0, connected: 0 }
$audio_device_accessible += { name: fmradio                 , driver: 0, connected: 0 }
# voicecall is always connected, we rely on xpolicy.conf info on whether the route exists
$audio_device_accessible += { name: voicecall               , driver: 0, connected: 1 }
$audio_device_accessible += { name: incompatible            , driver: 0, connected: 0 }


$audio_device_selectable  = { name: null                    , selectable: 1 } # Always connected, always selectable
$audio_device_selectable += { name: nullsource              , selectable: 0 }
$audio_device_selectable += { name: ihfforcall              , selectable: 1 } # Always connected, always selectable
$audio_device_selectable += { name: ihfforalien             , selectable: 1 } # Always connected, always selectable
$audio_device_selectable += { name: earpieceforalien        , selectable: 0 }
$audio_device_selectable += { name: ihf                     , selectable: 1 } # Always connected, always selectable
$audio_device_selectable += { name: microphone              , selectable: 1 } # Always connected, always selectable
$audio_device_selectable += { name: backmicrophone          , selectable: 1 } # Always connected, always selectable
$audio_device_selectable += { name: earpieceforcall         , selectable: 0 }
$audio_device_selectable += { name: earpiece                , selectable: 0 }
$audio_device_selectable += { name: earpieceandtvout        , selectable: 0 }
$audio_device_selectable += { name: tvout                   , selectable: 0 }
$audio_device_selectable += { name: ihfandtvout             , selectable: 0 }
$audio_device_selectable += { name: headmike                , selectable: 0 }
$audio_device_selectable += { name: headphoneforcall        , selectable: 0 }
$audio_device_selectable += { name: headphoneforalien       , selectable: 0 }
$audio_device_selectable += { name: headphone               , selectable: 0 }
$audio_device_selectable += { name: lineoutforcall          , selectable: 0 }
$audio_device_selectable += { name: lineoutforalien         , selectable: 0 }
$audio_device_selectable += { name: lineout                 , selectable: 0 }
$audio_device_selectable += { name: headsetforcall          , selectable: 0 }
$audio_device_selectable += { name: headsetforalien         , selectable: 0 }
$audio_device_selectable += { name: headset                 , selectable: 0 }
$audio_device_selectable += { name: bthfpforcall            , selectable: 0 }
$audio_device_selectable += { name: bthfpforalien           , selectable: 0 }
$audio_device_selectable += { name: bthfp                   , selectable: 0 }
$audio_device_selectable += { name: bthspforcall            , selectable: 0 }
$audio_device_selectable += { name: bthspforalien           , selectable: 0 }
$audio_device_selectable += { name: bthsp                   , selectable: 0 }
$audio_device_selectable += { name: bta2dp                  , selectable: 0 }
$audio_device_selectable += { name: bta2dpforalien          , selectable: 0 }
$audio_device_selectable += { name: ihfandheadset           , selectable: 0 }
$audio_device_selectable += { name: ihfandheadphone         , selectable: 0 }
$audio_device_selectable += { name: ihfandlineout           , selectable: 0 }
$audio_device_selectable += { name: tvoutandbta2dp          , selectable: 0 }
$audio_device_selectable += { name: usbaudio                , selectable: 0 }
$audio_device_selectable += { name: usbmic                  , selectable: 0 }
$audio_device_selectable += { name: fmradioloopback         , selectable: 0 }
$audio_device_selectable += { name: fmradio                 , selectable: 0 }
$audio_device_selectable += { name: headphoneasfmradiolp    , selectable: 0 }
$audio_device_selectable += { name: headsetasfmradiolp      , selectable: 0 }
$audio_device_selectable += { name: lineoutasfmradiolp      , selectable: 0 }
$audio_device_selectable += { name: headphoneasfmradio      , selectable: 0 }
$audio_device_selectable += { name: headsetasfmradio        , selectable: 0 }
$audio_device_selectable += { name: lineoutasfmradio        , selectable: 0 }
$audio_device_selectable += { name: voicecall               , selectable: 0 }
$audio_device_selectable += { name: incompatible            , selectable: 0 }


# preferred devices. this needs to be 1:1 copy of
# audio_device_selectable list.
$audio_device_preferred  = { name: null                     , preferred: 0 }
$audio_device_preferred += { name: nullsource               , preferred: 0 }
$audio_device_preferred += { name: ihfforcall               , preferred: 0 }
$audio_device_preferred += { name: ihfforalien              , preferred: 0 }
$audio_device_preferred += { name: earpieceforalien         , preferred: 0 }
$audio_device_preferred += { name: ihf                      , preferred: 0 }
$audio_device_preferred += { name: microphone               , preferred: 0 }
$audio_device_preferred += { name: backmicrophone           , preferred: 0 }
$audio_device_preferred += { name: earpieceforcall          , preferred: 0 }
$audio_device_preferred += { name: earpiece                 , preferred: 0 }
$audio_device_preferred += { name: earpieceandtvout         , preferred: 0 }
$audio_device_preferred += { name: tvout                    , preferred: 0 }
$audio_device_preferred += { name: ihfandtvout              , preferred: 0 }
$audio_device_preferred += { name: headmike                 , preferred: 0 }
$audio_device_preferred += { name: headphoneforcall         , preferred: 0 }
$audio_device_preferred += { name: headphoneforalien        , preferred: 0 }
$audio_device_preferred += { name: headphone                , preferred: 0 }
$audio_device_preferred += { name: headsetforcall           , preferred: 0 }
$audio_device_preferred += { name: headsetforalien          , preferred: 0 }
$audio_device_preferred += { name: headset                  , preferred: 0 }
$audio_device_preferred += { name: bthfpforcall             , preferred: 0 }
$audio_device_preferred += { name: bthfpforalien            , preferred: 0 }
$audio_device_preferred += { name: bthfp                    , preferred: 0 }
$audio_device_preferred += { name: bthspforcall             , preferred: 0 }
$audio_device_preferred += { name: bthspforalien            , preferred: 0 }
$audio_device_preferred += { name: bthsp                    , preferred: 0 }
$audio_device_preferred += { name: bta2dp                   , preferred: 0 }
$audio_device_preferred += { name: bta2dpforalien           , preferred: 0 }
$audio_device_preferred += { name: ihfandheadset            , preferred: 0 }
$audio_device_preferred += { name: ihfandheadphone          , preferred: 0 }
$audio_device_preferred += { name: tvoutandbta2dp           , preferred: 0 }
$audio_device_preferred += { name: usbaudio                 , preferred: 0 }
$audio_device_preferred += { name: usbmic                   , preferred: 0 }
$audio_device_preferred += { name: fmradioloopback          , preferred: 0 }
$audio_device_preferred += { name: fmradio                  , preferred: 0 }
$audio_device_preferred += { name: headphoneasfmradiolp     , preferred: 0 }
$audio_device_preferred += { name: headsetasfmradiolp       , preferred: 0 }
$audio_device_preferred += { name: headphoneasfmradio       , preferred: 0 }
$audio_device_preferred += { name: headsetasfmradio         , preferred: 0 }
$audio_device_preferred += { name: voicecall                , preferred: 0 }
$audio_device_preferred += { name: incompatible             , preferred: 0 }


# audio modes for ECI detection
$audio_mode  = { device: null                               , default: null             }
$audio_mode += { device: ihfforcall                         , default: ihf              }
$audio_mode += { device: ihfforalien                        , default: ihf              }
$audio_mode += { device: earpieceforalien                   , default: hp               }
$audio_mode += { device: ihf                                , default: ihf              }
$audio_mode += { device: earpieceforcall                    , default: hp               }
$audio_mode += { device: earpiece                           , default: hp               }
$audio_mode += { device: earpieceandtvout                   , default: hp               }
$audio_mode += { device: tvout                              , default: lineout          }
$audio_mode += { device: ihfandtvout                        , default:'ihfandtv-out'    }
$audio_mode += { device: headphoneforcall                   , default: lineout          }
$audio_mode += { device: headphoneforalien                  , default: lineout          }
$audio_mode += { device: headphone                          , default: lineout          }
$audio_mode += { device: lineoutforcall                     , default: lineout          }
$audio_mode += { device: lineoutforalien                    , default: lineout          }
$audio_mode += { device: lineout                            , default: lineout          }
$audio_mode += { device: headsetforcall                     , default: lineout          }
$audio_mode += { device: headsetforalien                    , default: lineout          }
$audio_mode += { device: headset                            , default: lineout          }
$audio_mode += { device: bthfpforcall                       , default: btmono           }
$audio_mode += { device: bthfpforalien                      , default: btmono           }
$audio_mode += { device: bthfp                              , default: btmono           }
$audio_mode += { device: bthspforcall                       , default: btmono           }
$audio_mode += { device: bthspforalien                      , default: btmono           }
$audio_mode += { device: bthsp                              , default: btmono           }
$audio_mode += { device: bta2dp                             , default: bta2dp           }
$audio_mode += { device: bta2dpforalien                     , default: bta2dp           }
$audio_mode += { device: tvoutandbta2dp                     , default: bta2dp           }
$audio_mode += { device: ihfandheadset                      , default: lineout          }
$audio_mode += { device: ihfandheadphone                    , default: lineout          }
$audio_mode += { device: ihfandlineout                      , default: lineout          }
$audio_mode += { device: usbaudio                           , default: usbaudio         }
$audio_mode += { device: headphoneasfmradiolp               , default: lineout          }
$audio_mode += { device: headsetasfmradiolp                 , default: lineout          }
$audio_mode += { device: lineoutasfmradiolp                 , default: lineout          }
$audio_mode += { device: headphoneasfmradio                 , default: lineout          }
$audio_mode += { device: headsetasfmradio                   , default: lineout          }
$audio_mode += { device: lineoutasfmradio                   , default: lineout          }


# audio output configuration - this list needs to include all output devices from
# audio_device_selectable list
$audio_output_configuration  = { device: null           , mode: null         ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: null }
$audio_output_configuration += { device: ihfforcall     , mode: ihf          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: speaker }
$audio_output_configuration += { device: ihfforalien    , mode: ihf          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: speaker }
$audio_output_configuration += { device: ihf            , mode: ihf          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: speaker }
$audio_output_configuration += { device: earpieceforalien, mode: hp          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiece }
$audio_output_configuration += { device: earpieceforcall, mode: hp           ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiece }
$audio_output_configuration += { device: earpiece       , mode: hp           ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiece }
$audio_output_configuration += { device: earpieceandtvout,mode: hp           ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiecendtvout }
$audio_output_configuration += { device: tvout          , mode: wired        ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: tvout }
$audio_output_configuration += { device: ihfandtvout    , mode:'ihfandtv-out',\
                                 hwid: na               , type: wired        ,\
                                 commonname: speakerandtvout }
$audio_output_configuration += { device: headphoneforcall,mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headphone }
$audio_output_configuration += { device: headphoneforalien,mode: lineout     ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headphone }
$audio_output_configuration += { device: headphone      , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headphone }
$audio_output_configuration += { device: lineoutforcall , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: lineout }
$audio_output_configuration += { device: lineoutforalien, mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: lineout }
$audio_output_configuration += { device: lineout        , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: lineout }
$audio_output_configuration += { device: headsetforcall , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headset }
$audio_output_configuration += { device: headsetforalien, mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headset }
$audio_output_configuration += { device: headset        , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headset }
$audio_output_configuration += { device: bthfpforcall   , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthfpforalien  , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthfp          , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthspforcall   , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthspforalien  , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthsp          , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bta2dpforalien , mode: bta2dp       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetootha2dp }
$audio_output_configuration += { device: bta2dp         , mode: bta2dp       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetootha2dp }
$audio_output_configuration += { device: ihfandheadset  , mode:ihfandheadset ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: speakerandheadset }
$audio_output_configuration += { device: ihfandheadphone , mode:ihfandlineout,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: speakerandheadphone }
$audio_output_configuration += { device: ihfandlineout  , mode:ihfandlineout ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: speakerandlineout  }
$audio_output_configuration += { device: tvoutandbta2dp , mode: bta2dp       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: tvoutandbluetootha2dp }
$audio_output_configuration += { device: usbaudio       , mode: usbaudio     ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: usbaudio }
$audio_output_configuration += { device: incompatible   , mode: lineout      ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: incompatible }

# audio input configuration - this list needs to include all input devices from
# audio_device_selectable list
$audio_input_configuration   = { device: nullsource           , type: builtin ,\
                                 commonname: null }
$audio_input_configuration  += { device: microphone           , type: builtin ,\
                                 commonname: microphone }
$audio_input_configuration  += { device: backmicrophone       , type: builtin ,\
                                 commonname: backmicrophone }
$audio_input_configuration  += { device: headmike             , type: wired   ,\
                                 commonname: headmike }
$audio_input_configuration  += { device: headset              , type: wired   ,\
                                 commonname: headset }
$audio_input_configuration  += { device: headsetforcall       , type: wired   ,\
                                 commonname: headset }
$audio_input_configuration  += { device: headsetforalien      , type: wired   ,\
                                 commonname: headset }
$audio_input_configuration  += { device: bthfp                , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthfpforcall         , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthfpforalien        , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthsp                , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthspforcall         , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthspforalien        , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: usbmic               , type: wired   ,\
                                 commonname: usbaudio }
$audio_input_configuration  += { device: headphoneasfmradiolp , type: wired   ,\
                                 commonname: fmradioloopback }
$audio_input_configuration  += { device: headsetasfmradiolp   , type: wired   ,\
                                 commonname: fmradioloopback }
$audio_input_configuration  += { device: lineoutasfmradiolp   , type: wired   ,\
                                 commonname: fmradioloopback }
$audio_input_configuration  += { device: headphoneasfmradio   , type: wired   ,\
                                 commonname: fmradio }
$audio_input_configuration  += { device: headsetasfmradio     , type: wired   ,\
                                 commonname: fmradio }
$audio_input_configuration  += { device: lineoutasfmradio     , type: wired   ,\
                                 commonname: fmradio }
$audio_input_configuration  += { device: voicecall            , type: builtin ,\
                                 commonname: voicecallrecord }
$audio_input_configuration  += { device: incompatible         , type: builtin ,\
                                 commonname: incompatible }

$privacy = { stage: previous, value: public }
$privacy = { stage: current , value: public }
 
# audio routing
$audio_route  = { type: source, device: microphone, mode: na , hwid: na }
$audio_route += { type: sink  , device: ihf       , mode: ihf, hwid: na }

# volume limits
$volume_limit  = { group: idle       , limit: 100 }
$volume_limit += { group: background , limit: 100 }
$volume_limit += { group: inputsound , limit: 100 }
$volume_limit += { group: systemsound, limit: 100 }
$volume_limit += { group: feedbacksound, limit: 100 }
$volume_limit += { group: event      , limit: 100 }
$volume_limit += { group: othermedia , limit: 100 }
$volume_limit += { group: flash      , limit: 100 }
$volume_limit += { group: player     , limit: 100 }
$volume_limit += { group: game       , limit: 100 }
$volume_limit += { group: alarm      , limit: 100 }
$volume_limit += { group: ringtone   , limit: 100 }
$volume_limit += { group: camera     , limit: 100 }
$volume_limit += { group: videoeditor, limit: 100 }
$volume_limit += { group: call       , limit: 100 }
$volume_limit += { group: aliencall  , limit: 100 }
$volume_limit += { group: navigator  , limit: 100 }
$volume_limit += { group: cstone     , limit: 100 }
$volume_limit += { group: alien      , limit: 100 }
$volume_limit += { group: btnotify   , limit: 100 }
$volume_limit += { group: nonsilent  , limit: 100 }
$volume_limit += { group: alwayson   , limit: 100 }

# audio corking
$audio_cork  = { group: idle       , cork: uncorked }
$audio_cork += { group: background , cork: uncorked }
$audio_cork += { group: systemsound, cork: uncorked }
$audio_cork += { group: feedbacksound, cork: uncorked }
$audio_cork += { group: inputsound , cork: uncorked }
$audio_cork += { group: event      , cork: uncorked }
$audio_cork += { group: alarm      , cork: uncorked }
$audio_cork += { group: othermedia , cork: uncorked }
$audio_cork += { group: flash      , cork: uncorked }
$audio_cork += { group: player     , cork: uncorked }
$audio_cork += { group: game       , cork: uncorked }
$audio_cork += { group: ringtone   , cork: uncorked }
$audio_cork += { group: camera     , cork: uncorked }
$audio_cork += { group: videoeditor, cork: uncorked }
$audio_cork += { group: call       , cork: uncorked }
$audio_cork += { group: aliencall  , cork: uncorked }
$audio_cork += { group: navigator  , cork: uncorked }
$audio_cork += { group: cstone     , cork: uncorked }
$audio_cork += { group: alien      , cork: uncorked }
$audio_cork += { group: btnotify   , cork: uncorked }
$audio_cork += { group: nonsilent  , cork: uncorked }
$audio_cork += { group: alwayson   , cork: uncorked }

# muting
$audio_mute    = { device: microphone           , mute: unmuted }
$audio_mute   += { device: backmicrophone       , mute: unmuted }
$audio_mute   += { device: headmike             , mute: unmuted }
$audio_mute   += { device: headsetforcall       , mute: unmuted }
$audio_mute   += { device: headsetforalien      , mute: unmuted }
$audio_mute   += { device: headset              , mute: unmuted }
$audio_mute   += { device: bthfpforcall         , mute: unmuted }
$audio_mute   += { device: bthfpforalien        , mute: unmuted }
$audio_mute   += { device: bthfp                , mute: unmuted }
$audio_mute   += { device: bthspforcall         , mute: unmuted }
$audio_mute   += { device: bthspforalien        , mute: unmuted }
$audio_mute   += { device: bthsp                , mute: unmuted }
$audio_mute   += { device: usbmic               , mute: unmuted }
$audio_mute   += { device: voicecall            , mute: unmuted }
$audio_mute   += { device: fmradio              , mute: unmuted }
$audio_mute   += { device: fmradioloopback      , mute: unmuted }
$audio_mute   += { device: headphoneasfmradiolp , mute: unmuted }
$audio_mute   += { device: headsetasfmradiolp   , mute: unmuted }
$audio_mute   += { device: lineoutasfmradiolp   , mute: unmuted }
$audio_mute   += { device: headphoneasfmradio   , mute: unmuted }
$audio_mute   += { device: headsetasfmradio     , mute: unmuted }
$audio_mute   += { device: lineoutasfmradio     , mute: unmuted }
$audio_mute   += { device: nullsource           , mute: unmuted }

# vibra control
$vibra_mute  = { group: other, mute: unmuted }
$vibra_mute += { group: game , mute: unmuted }
$vibra_mute += { group: ui   , mute: unmuted }
$vibra_mute += { group: event, mute: unmuted }

# backlight control
$backlight   = { state: off }

# currently active (topmost) application id
$policy_active_application = { id: 'no-application' }
# app support application id
$policy_active_appsupport = { id: 'no-appsupport' }

# features
$feature   = { name: emergencycall      , allowed: 1        , enabled: 0 }
$feature  += { name: fmradio            , allowed: 0        , enabled: 0 }
$feature  += { name: fmradioloopback    , allowed: 0        , enabled: 0 }
$feature  += { name: voicecallrecord    , allowed: 0        , enabled: 0 }
$feature  += { name: speaker            , allowed: 0        , enabled: 0 }
$feature  += { name: bluetooth_override , allowed: 0        , enabled: 0 }

# mobile device management
$mdm       = { name: microphone         , value: enabled }

# contexts
$context   = { variable: call                   ,  value: inactive }
$context   = { variable: bluetooth_override     ,  value: disabled }  # disabled - active - inactive
$context   = { variable: media_state            ,  value: inactive }  # inactive - background - foreground - active
$context   = { variable: voicecall_record       ,  value: disabled }  # disabled - enabled
$context   = { variable: emergency_call         ,  value: inactive }  # inactive - active
#$context   = { variable: call_audio_type,  value: none     }
#$context   = { variable: camera         ,  value: inactive }

# sensors
$proximity = { state: 'unknown' }

# mute state for microphones
$mute  = { default_value: 0, value: 0 }

# override audio route from bluetooth to other devices
$bluetooth_override = { default_value: default, value: default }

#
# we always need at least one enforcement point
# (workaround for a resolver factstore tracking buglet/feature...)
# 
$enforcement_point = { id: 'ohmd', type: 'internal', name: 'ohmd' }

# policy plugin states, and resolver blocking
$plugin   = { name: 'ohmd', type: 'policy', state: 'ready' }
$resolver = { blocked: 0 }

# internally used variables
$completion_handler_called = { value: no }

# workaround to reference variables in requests
$ref = { variable_a:0, variable_b:0 }

all: plugin_check               \
     video_route                \
     audio_route                \
     audio_volume               \
     audio_cork                 \
     audio_mute                 \
     context                    \
     update_feature_allowed     \
     update_feature_enabled     \
     $vibra_mute                \
     $backlight                 \
     $enforcement_point

	if !$resolver:blocked then
	    #echo('*** all ***')
	    $completion_handler_called:value = no
	    resolve(actions, &completion_callback=&completion_callback, \
                    &transaction_id=&transaction_id)
	    #if $completion_handler_called:value == 'no' then
	    #	delay_execution(0, 'completion', &completion_callback, \
	    #    	            &transaction_id, 1)
	    #end
	end

update_feature_allowed: $context $audio_device_selectable
	# disable fmradio feature when call is starting
	if $context[variable:call]:value != 'inactive' then
		$feature[name:fmradio]:allowed = 0
		$feature[name:fmradioloopback]:allowed = 0
	end

	if $context[variable:call]:value == 'incoming' || \
	   $context[variable:call]:value == 'inactive' then
		# fmradio is allowed only when call is not active
		# however, keep allow on during ringtone as well so that
		# enabled state is not reset during incoming call
		if $audio_device_selectable[name:headset]:selectable == 1               || \
		   $audio_device_selectable[name:headsetforcall]:selectable == 1        || \
		   $audio_device_selectable[name:headsetforalien]:selectable == 1       || \
		   $audio_device_selectable[name:headphone]:selectable == 1             || \
		   $audio_device_selectable[name:headphoneforcall]:selectable == 1      || \
		   $audio_device_selectable[name:headphoneforalien]:selectable == 1     || \
		   $audio_device_selectable[name:lineout]:selectable == 1               || \
		   $audio_device_selectable[name:lineoutforcall]:selectable == 1        || \
		   $audio_device_selectable[name:lineoutforalien]:selectable == 1       || \
		   $audio_device_selectable[name:ihfandlineout]:selectable == 1         || \
		   $audio_device_selectable[name:ihfandheadphone]:selectable == 1       || \
		   $audio_device_selectable[name:ihfandheadset]:selectable == 1         then
			$feature[name:fmradio]:allowed = 1
			$feature[name:fmradioloopback]:allowed = 1
		else
			$feature[name:fmradio]:allowed = 0
			$feature[name:fmradio]:enabled = 0
			$feature[name:fmradioloopback]:allowed = 0
			$feature[name:fmradioloopback]:enabled = 0
		end

	end

	if $audio_device_selectable[name:bthspforcall]:selectable == 1              || \
	   $audio_device_selectable[name:bthfpforcall]:selectable == 1              && \
	   $context[variable:call]:value != 'inactive'                              then
		$feature[name:bluetooth_override]:allowed = 1
	else
		$feature[name:bluetooth_override]:allowed = 0
		$feature[name:bluetooth_override]:enabled = 0
	end

	# speaker routing is allowed only when fmradio or emergencycall feature is enabled,
	# aliencall resource class is active, or while phone call is active
	if $feature[name:fmradioloopback]:enabled == 1      || \
	   $feature[name:fmradio]:enabled == 1              || \
	   $feature[name:emergencycall]:enabled == 1        || \
	   $audio_resource_owner:current == 'aliencall'     || \
	   $context[variable:call]:value == 'outgoing'      || \
	   $context[variable:call]:value == 'active'        then
		$feature[name:speaker]:allowed = 1
	else
		$feature[name:speaker]:allowed = 0
		$feature[name:speaker]:enabled = 0
	end

update_feature_enabled: $feature
	resolve(fmradioloopback_feature_update)
	resolve(fmradio_feature_update)
	resolve(speaker_feature_update)
	resolve(bluetooth_override_feature_update)
	resolve(audio_route)

fmradioloopback_feature_update: $feature
	if $feature[name:fmradioloopback]:enabled == 1 then
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradioloopback', 1, 1)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradioloopback', 1, 1)
	else
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradioloopback', 0, 0)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradioloopback', 0, 0)
	end

fmradio_feature_update: $feature
	if $feature[name:fmradio]:enabled == 1 then
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradio', 1, 1)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradio', 1, 1)
	else
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradio', 0, 0)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradio', 0, 0)
	end

speaker_feature_update: $feature
	if $feature[name:speaker]:enabled == 1 then
		$audio_device_preferred[name] = prolog(set_preferred_audio_entry,\
		                                       'speaker',\
		                                       1)
	else
		$audio_device_preferred[name] = prolog(set_preferred_audio_entry,\
		                                       'speaker',\
		                                       0)
	end

bluetooth_override_feature_update: $feature
	if $feature[name:bluetooth_override]:enabled == 1 then
		$bluetooth_override:value = 'earpiece'
	else
		$bluetooth_override:value = $bluetooth_override:default_value
	end

feature_request:
	# allow enabling only when allowed is true, disabling is allowed always
	if $feature[name:&feature_name]:allowed == 1 || &value == 0 then
		$feature[name:&feature_name]:enabled = &value
		if &feature_name == 'fmradio'           ||\
		   &feature_name == 'fmradioloopback'   then
				$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
				                                        &feature_name, &value, &value)
				$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
				                                        &feature_name, &value, &value)
		end
		if &feature_name == 'speaker' then
			resolve(speaker_feature_update)
		end
		resolve(all)
	end

mdm_request:
	$mdm[name:&mdm_name]:value = &mdm_value
	if $mdm[name:microphone]:value == 'enabled' && \
	   $audio_device_accessible[name:voicecall]:driver == 1 \
	then
		$feature[name:voicecallrecord]:allowed = 1
	else
		$feature[name:voicecallrecord]:allowed = 0
	end
	resolve(all)

video_route: $video_device_selectable $gconf
	$video_route = prolog(set_video_routes)

audio_route: $audio_device_selectable $audio_output_configuration \
             $resource_owner $bluetooth_override \
             $current_profile $mdm $audio_device_preferred
	$privacy[stage]    |= prolog(set_audio_privacy, previous)
	$audio_route[type] |= prolog(set_audio_routes)
	$privacy[stage]    |= prolog(set_audio_privacy, current)
	# If call is ending and we are going to public route, force release resources
	# Or, if call is ending, and when call was starting route was public, but
	# after call ends route is private, force release resources (use case:
	# listen to music speaker, answer call, plug headset in for the duration of
	# the call, end call with headset connected -> audio stays paused)
	if $ignore_privacy_change:value == 0 &&                 \
	   (($call_start_privacy:value != 'private' &&          \
	   (($privacy[stage:previous]:value == 'private' ||     \
	        ($audio_resource_owner:previous == 'call' &&    \
	         $audio_resource_owner:current != 'call')) &&   \
	   $privacy[stage:current]:value  == 'public')) ||      \
	   ($call_start_privacy:value == 'public' &&            \
	        $audio_resource_owner:previous == 'call' &&     \
	         $audio_resource_owner:current != 'call' &&     \
	   $privacy[stage:current]:value  == 'private'))        \
	then
	    #echo('*** stop players ***')
	    #echo('$privacy[stage:previous]:value ==', $privacy[stage:previous]:value, '$privacy[stage:current]:value ==', $privacy[stage:current]:value, '$audio_resource_owner:previous ==', $audio_resource_owner:previous, '$audio_resource_owner:current ==', $audio_resource_owner:current, '$call_start_privacy:value ==', $call_start_privacy:value)
	    if $feature[name:speaker]:enabled != 1 then
	        $resource_set[manager_id] |= prolog(force_resource_release, \
	                                            implicit, player)
	        $resource_set[manager_id] |= prolog(force_resource_release, \
	                                            player, player)
	    end
	end
	$ignore_privacy_change:value = 0

audio_volume: $resource_owner $resource_set $volume_limit \
              $current_profile  $audio_route
	$volume_limit[group] |= prolog(set_volume_limits)

audio_cork: $resource_owner $audio_cork
	$audio_cork[group] |= prolog(set_corks)

audio_mute: $mute
	$audio_mute[device] |= prolog(set_mute)

audio_mute_request:
	$mute:value = &mute_state
	resolve(all)

audio_mute_reset:
	$mute:value = $mute:default_value

privacy_override_request:
	if &privacy_override_state == 'public' then
		$feature[name:speaker]:enabled = 1
		$audio_device_preferred[name] = prolog(set_preferred_audio_entry,\
		                                       'speaker',\
		                                       1)
	else
		$feature[name:speaker]:enabled = 0
		$audio_device_preferred[name] = prolog(set_preferred_audio_entry,\
		                                       'speaker',\
		                                       0)
	end
	resolve(all)

privacy_override_reset:
	$audio_device_preferred[name] = prolog(clear_preferred_audio_entry)
	$feature[name:speaker]:enabled = 0

bluetooth_override_request:
	if &bluetooth_override_state == 'disconnected' || &bluetooth_override_state == 'default' then
		$bluetooth_override:value = $bluetooth_override:default_value
		$feature[name:bluetooth_override]:enabled = 0
	else
		$bluetooth_override:value = &bluetooth_override_state
		$feature[name:bluetooth_override]:enabled = 1
	end
	resolve(all)

reset_bluetooth_override:
	$bluetooth_override:value = $bluetooth_override:default_value
	$feature[name:bluetooth_override]:enabled = 0

actions: audio_actions video_actions vibra_actions backlight_actions

audio_actions: $audio_mute $audio_cork $volume_limit $context $audio_route \
               $enforcement_point
	#echo('*** audio_actions ***')
	signal_changed(audio_actions, &completion_callback, &transaction_id, \
	               'com.nokia.policy.context', \
                       'com.nokia.policy.volume_limit', \
                       'com.nokia.policy.audio_route', \
                       'com.nokia.policy.audio_cork', \
		       'com.nokia.policy.audio_mute')
	$completion_handler_called:value = yes

video_actions: $video_route $enforcement_point
	#echo('*** video_actions ***')
	signal_changed(video_actions, '', 0, \
	               'com.nokia.policy.video_route')

vibra_actions: $vibra_mute
	#echo('*** vibra_actions ***')
	signal_changed(vibra_actions, '', 0, \
		       'com.nokia.policy.vibra_mute')

backlight_actions: $backlight
	#echo('*** backlight_actions ***')
	signal_changed(backlight_actions, '', 0, \
		       'com.nokia.policy.backlight')

resource_request:
	#echo('*** resource_request: ', &request, ' ', &manager_id)
	$ref:variable_a = &request
	$ref:variable_b = &manager_id
	$audio_resource_owner:previous = $resource_owner[resource:audio_playback]:owner
	$active_audio_manager_id = prolog(get_active_audio_manager_id)
	$active_audio_manager:previous = $active_audio_manager_id:id
	#echo('$active_audio_manager:previous changes to ', $active_audio_manager:previous)
	$resource_set[manager_id] |= prolog(update_resource_entries)
	$resource_owner[resource] |= prolog(update_resource_owner_entries)
	$audio_resource_owner:current = $resource_owner[resource:audio_playback]:owner
	$active_audio_manager_id = prolog(get_active_audio_manager_id)
	$active_audio_manager:current = $active_audio_manager_id:id
	#echo('$active_audio_manager:current changes to ', $active_audio_manager:current)

	# If active manager_id changes release the previous active playback, so that when the
	# new player pauses, previously active playback won't continue.
	if $active_audio_manager:previous != 0 &&                               \
	   $active_audio_manager:current != 0 &&                                \
	       ($audio_resource_owner:previous == 'player' ||                   \
	        $audio_resource_owner:previous == 'game') &&                    \
	   $audio_resource_owner:previous == $audio_resource_owner:current &&   \
	   $active_audio_manager:previous != $active_audio_manager:current      \
	   then
	    #echo('*** force_resource_release_one ', $active_audio_manager:previous)
	    $resource_set[manager_id] |= prolog(force_resource_release_one, $active_audio_manager:previous)
	end

	resolve(all)


accessory_request:
	$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
	                                        &accessory_name, \
					        &accessory_driver, \
					        &accessory_connected)
	$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
	                                        &accessory_name, \
						&accessory_driver, \
						&accessory_connected)
	$audio_device_preferred[name] = prolog(update_preferred_audio_entry)
	$video_device_accessible[name] = prolog(update_accessible_video_entry,\
	                                        &accessory_name, \
						&accessory_connected)
	$video_device_selectable[name] = prolog(update_selectable_video_entry,\
	                                        &accessory_name, \
						&accessory_connected)

	if $mdm[name:microphone]:value == 'enabled' && \
	   $audio_device_accessible[name:voicecall]:driver == 1 \
	then
		$feature[name:voicecallrecord]:allowed = 1
	end

	resolve(all, '', 0)


prefer_request:
	$ignore_privacy_change:value = 1
	$audio_device_preferred[name] = prolog(set_preferred_audio_entry,\
	                                       &accessory_name,\
	                                       &accessory_preferred)
	resolve(all, '', 0)


update_accessory_mode:
	$audio_output_configuration[device] |= prolog(update_accessory_mode, \
					 	      &accessory_name,       \
						      &accessory_mode)

card_profile_changed_request:
	if ($feature[name:bluetooth_override]:allowed == 1 && \
	    (&card_type == 'bthspforcall' || &card_type == 'bthfpforcall')) then
		if (&card_profile == 'off') then
			if (($audio_route[type:sink]:device == 'bthfpforcall' || \
			     $audio_route[type:sink]:device == 'bthspforcall') && \
			    $feature[name:bluetooth_override]:enabled == 0) then

				$feature[name:bluetooth_override]:enabled = 1
				resolve(bluetooth_override_feature_update, '', 0)
				resolve(all, '', 0)
			end
		else
			if $feature[name:bluetooth_override]:enabled == 1 then
				$feature[name:bluetooth_override]:enabled = 0
				resolve(bluetooth_override_feature_update, '', 0)
				resolve(all, '', 0)
			end
		end
	end

telephony_request:
	$call_action = prolog(call_request, &call_id, &call_state)

telephony_audio_update:

#
# application_request
#
active_ui_change_request:
	echo('*** active_ui_change_request appwin=', &appwin, \
                  ' pid=', &pid , ' iconize=', &iconize, ' ***')

# Bluetooth HFP/HSP state machine hooks

# Bluetooth HSP goes from connected to playing state
bthsp_start_audio:

# Bluetooth HSP goes from playing to connected state
bthsp_stop_audio:

bthsp_disconnect:

bthsp_connect:

# Bluetooth HFP goes from connected to playing state
bthfp_start_audio:

# Bluetooth HFP goes from playing to connected state
bthfp_stop_audio:

bthfp_disconnect:

bthfp_connect:


# first call hook
telephony_first_call_hook: audio_mute_reset privacy_override_reset reset_bluetooth_override
	#$mode[foo] = prolog(update_mode, telephony)
	if $call_start_privacy:value == 'none' \
	then
	    $call_start_privacy:value = $privacy[stage:current]:value
	end

# last call hook
telephony_last_call_hook: audio_mute_reset privacy_override_reset reset_bluetooth_override
	#$mode[foo] = prolog(update_mode)
	# resolve(all, '', 0)
	$call_start_privacy:value = none

# call start hook: workaround for tonegen bad audio quality at call start
telephony_call_start_hook:

# local hungup hook
telephony_local_hungup_hook:

# call end hook
telephony_call_end_hook:

# call connect hook (call locally accepted)
telephony_call_connect_hook:

# call onhold hook
telephony_call_onhold_hook:

# call offhold hook
telephony_call_offhold_hook:

# call active hook (call remotely accepted)
telephony_call_active_hook:

# dialstring sending started
telephony_sending_dialstring:

# dialstring sending stopped
telephony_stopped_dialstring:

policy_active_application_request:
	if &id == 'none' || &id == '' then
		$policy_active_application:id = 'no-application'
	else
		$policy_active_application:id = &id
	end

policy_active_appsupport_request:
	if &id == 'none' || &id == '' then
		$policy_active_appsupport:id = 'no-appsupport'
	else
		$policy_active_appsupport:id = &id
	end

# context variables:
# call                  - com.nokia.policy.call ($call) changes
# bluetooth_override    - com.nokia.policy.bluetooth_override ($bluetooth_override) changes
# media_state           - com.nokia.policy.media_state
context: $bluetooth_override        \
         $resource_set              \
         $feature                   \
         $policy_active_application \
         $policy_active_appsupport
	$context[variable] |= prolog(update_contexts)

# block resolving if any policy plugin is not ready
plugin_check: $plugin
	if $plugin[type:policy, state:!ready] then
	    $resolver:blocked = 1
	else
	    $resolver:blocked = 0
	end

# forcibly intern 'rule' (alias for 'prolog') into the symbol table
__alias_prolog:
	rule(foo, bar)
