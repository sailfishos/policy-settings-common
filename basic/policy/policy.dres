# -*-makefile-*-
PREFIX = com.nokia.policy

# resource
$resource_owner  = {resource: headset_buttons, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: lens_cover,      owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: snap_button,     owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: scale_button,    owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: lock_button,     owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: system_button,   owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: backlight,       owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: leds,            owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: vibra,           owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: video_recording, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: audio_recording, owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: video_playback , owner: nobody, mode: shared, \
                    group   : nobody }
$resource_owner += {resource: audio_playback , owner: nobody, mode: shared, \
                    group   : nobody }

$audio_resource_owner = { previous: nobody, current: nobody }
$active_audio_manager_id = { id: 0 }
$active_audio_manager = { previous: 0, current: 0 }
$call_start_privacy = { value: none }

$resource_set = {manager_id:0,  client_name:dres, client_id:0, class:fake,    \
                 mode:0, mandatory:0, optional:0, shared:0, mask:0, granted:0,\
                 advice:0, request:release, block:0, reqno:0, audiogr:fake}


# video devices
$video_device_accessible  = { name: tvout          , connected: 0 }
$video_device_accessible += { name: builtin        , connected: 1 }

$video_device_selectable  = { name: builtinandtvout, selectable: 0 }
$video_device_selectable += { name: tvout          , selectable: 0 }
$video_device_selectable += { name: builtin        , selectable: 1 }

# video routing
$video_route = { device: builtin, tvstandard: pal, aspectratio: normal }

# audio devices
$audio_device_accessible  = { name: null          , driver: 1, connected: 1 }
$audio_device_accessible += { name: ihf           , driver: 1, connected: 1 }
$audio_device_accessible += { name: microphone    , driver: 1, connected: 1 }
$audio_device_accessible += { name: backmicrophone, driver: 1, connected: 1 }
$audio_device_accessible += { name: earpiece      , driver: 1, connected: 1 }
$audio_device_accessible += { name: tvout         , driver: 1, connected: 0 }
$audio_device_accessible += { name: headmike      , driver: 1, connected: 0 }
$audio_device_accessible += { name: headphone     , driver: 1, connected: 0 }
$audio_device_accessible += { name: headset       , driver: 1, connected: 0 }
$audio_device_accessible += { name: bthsp         , driver: 0, connected: 0 }
$audio_device_accessible += { name: bta2dp        , driver: 0, connected: 0 }
# We consider the usbaudio device to be always connected, as the driver and
# selectable are updated when the interface appears.
# We will never route to usbaudio unless the device is selectable, so this
# shouldn't cause any problems.
$audio_device_accessible += { name: usbaudio      , driver: 0, connected: 1 }
$audio_device_accessible += { name: fmradioloopback, driver: 0, connected: 0 }
$audio_device_accessible += { name: fmradio       , driver: 0, connected: 0 }
$audio_device_accessible += { name: voicecall     , driver: 0, connected: 0 }
$audio_device_accessible += { name: incompatible  , driver: 0, connected: 0 }

$audio_device_selectable  = { name: null            , selectable: 1 }
$audio_device_selectable += { name: ihfforcall      , selectable: 1 }
$audio_device_selectable += { name: ihfforalien     , selectable: 1 }
$audio_device_selectable += { name: earpieceforalien, selectable: 1 }
$audio_device_selectable += { name: ihf             , selectable: 1 }
$audio_device_selectable += { name: microphone      , selectable: 1 }
$audio_device_selectable += { name: backmicrophone  , selectable: 1 }
$audio_device_selectable += { name: earpiece        , selectable: 1 }
$audio_device_selectable += { name: earpieceandtvout, selectable: 0 }
$audio_device_selectable += { name: tvout           , selectable: 0 }
$audio_device_selectable += { name: ihfandtvout     , selectable: 0 }
$audio_device_selectable += { name: headmike        , selectable: 0 }
$audio_device_selectable += { name: headphoneforcall, selectable: 0 }
$audio_device_selectable += { name: headphoneforalien,selectable: 0 }
$audio_device_selectable += { name: headphone       , selectable: 0 }
$audio_device_selectable += { name: headsetforcall  , selectable: 0 }
$audio_device_selectable += { name: headsetforalien , selectable: 0 }
$audio_device_selectable += { name: headset         , selectable: 0 }
$audio_device_selectable += { name: bthspforcall    , selectable: 0 }
$audio_device_selectable += { name: bthspforalien   , selectable: 0 }
#$audio_device_selectable += { name: bthspforcall    , selectable: 1 }
$audio_device_selectable += { name: bthsp           , selectable: 0 }
$audio_device_selectable += { name: bta2dp          , selectable: 0 }
$audio_device_selectable += { name: bta2dpforalien  , selectable: 0 }
$audio_device_selectable += { name: ihfandheadset   , selectable: 0 }
$audio_device_selectable += { name: ihfandheadphone , selectable: 0 }
$audio_device_selectable += { name: ihfandbthsp     , selectable: 0 }
$audio_device_selectable += { name: tvoutandbthsp   , selectable: 0 }
$audio_device_selectable += { name: tvoutandbta2dp  , selectable: 0 }
$audio_device_selectable += { name: usbaudio        , selectable: 0 }
$audio_device_selectable += { name: fmradioloopback, selectable: 0 }
$audio_device_selectable += { name: fmradio         , selectable: 0 }
$audio_device_selectable += { name: headphoneasfmradiolp, selectable: 0 }
$audio_device_selectable += { name: headsetasfmradiolp  , selectable: 0 }
$audio_device_selectable += { name: headphoneasfmradio  , selectable: 0 }
$audio_device_selectable += { name: headsetasfmradio    , selectable: 0 }
$audio_device_selectable += { name: voicecall       , selectable: 0 }
$audio_device_selectable += { name: incompatible    , selectable: 0 }


# audio modes for ECI detection
$audio_mode  = { device: null            , default: null          }
$audio_mode += { device: ihfforcall      , default: ihf           }
$audio_mode += { device: ihfforalien     , default: ihf           }
$audio_mode += { device: earpieceforalien, default: hp            }
$audio_mode += { device: ihf             , default: ihf           }
$audio_mode += { device: earpiece        , default: hp            }
$audio_mode += { device: earpieceandtvout, default: hp            }
$audio_mode += { device: tvout           , default: lineout       }
$audio_mode += { device: ihfandtvout     , default:'ihfandtv-out' }
$audio_mode += { device: headphoneforcall, default: lineout       }
$audio_mode += { device: headphoneforalien,default: lineout       }
$audio_mode += { device: headphone       , default: lineout       }
$audio_mode += { device: headsetforcall  , default: lineout       }
$audio_mode += { device: headsetforalien , default: lineout       }
$audio_mode += { device: headset         , default: lineout       }
$audio_mode += { device: bthspforcall    , default: btmono        }
$audio_mode += { device: bthspforalien   , default: btmono        }
$audio_mode += { device: bthsp           , default: btmono        }
$audio_mode += { device: bta2dp          , default: bta2dp        }
$audio_mode += { device: bta2dpforalien  , default: bta2dp        }
$audio_mode += { device: ihfandbthsp     , default: ihfandbtmono  }
$audio_mode += { device: tvoutandbthsp   , default: btmono        }
$audio_mode += { device: tvoutandbta2dp  , default: bta2dp        }
$audio_mode += { device: ihfandheadset   , default: ihfandheadset }
$audio_mode += { device: ihfandheadphone , default: ihfandlineout }
$audio_mode += { device: usbaudio        , default: usbaudio      }
$audio_mode += { device: headphoneasfmradiolp, default: lineout   }
$audio_mode += { device: headsetasfmradiolp  , default: lineout   }
$audio_mode += { device: headphoneasfmradio  , default: lineout   }
$audio_mode += { device: headsetasfmradio    , default: lineout   }


# audio output configuration - this list needs to include all output devices from
# audio_device_selectable list
$audio_output_configuration  = { device: null           , mode: null         ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: null }
$audio_output_configuration += { device: ihfforcall     , mode: ihf          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: speaker }
$audio_output_configuration += { device: ihfforalien    , mode: ihf          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: speaker }
$audio_output_configuration += { device: ihf            , mode: ihf          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: speaker }
$audio_output_configuration += { device: earpieceforalien, mode: hp          ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiece }
$audio_output_configuration += { device: earpiece       , mode: hp           ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiece }
$audio_output_configuration += { device: earpieceandtvout,mode: hp           ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: earpiecendtvout }
$audio_output_configuration += { device: tvout          , mode: wired        ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: tvout }
$audio_output_configuration += { device: ihfandtvout    , mode:'ihfandtv-out',\
                                 hwid: na               , type: wired        ,\
                                 commonname: speakerandtvout }
$audio_output_configuration += { device: headphoneforcall,mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headphone }
$audio_output_configuration += { device: headphoneforalien,mode: lineout     ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headphone }
$audio_output_configuration += { device: headphone      , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headphone }
$audio_output_configuration += { device: headsetforcall , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headset }
$audio_output_configuration += { device: headsetforalien, mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headset }
$audio_output_configuration += { device: headset        , mode: lineout      ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: headset }
$audio_output_configuration += { device: bthspforcall   , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthspforalien  , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bthsp          , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetoothsco }
$audio_output_configuration += { device: bta2dpforalien , mode: bta2dp       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetootha2dp }
$audio_output_configuration += { device: bta2dp         , mode: bta2dp       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: bluetootha2dp }
$audio_output_configuration += { device: ihfandheadset  , mode:ihfandheadset ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: speakerandheadset }
$audio_output_configuration += { device: ihfandheadphone , mode:ihfandlineout,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: speakerandheadphone }
$audio_output_configuration += { device: ihfandbthsp    , mode: ihfandbtmono ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: speakerandbluetoothsco }
$audio_output_configuration += { device: tvoutandbthsp  , mode: btmono       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: tvoutandbluetoothsco }
$audio_output_configuration += { device: tvoutandbta2dp , mode: bta2dp       ,\
                                 hwid: na               , type: wireless     ,\
                                 commonname: tvoutandbluetootha2dp }
$audio_output_configuration += { device: usbaudio       , mode: usbaudio     ,\
                                 hwid: na               , type: wired        ,\
                                 commonname: usbaudio }
$audio_output_configuration += { device: incompatible   , mode: lineout      ,\
                                 hwid: na               , type: builtin      ,\
                                 commonname: incompatible }

# audio input configuration - this list needs to include all input devices from
# audio_device_selectable list
$audio_input_configuration   = { device: null                 , type: builtin ,\
                                 commonname: null }
$audio_input_configuration  += { device: microphone           , type: builtin ,\
                                 commonname: microphone }
$audio_input_configuration  += { device: backmicrophone       , type: builtin ,\
                                 commonname: backmicrophone }
$audio_input_configuration  += { device: headmike             , type: wired   ,\
                                 commonname: headmike }
$audio_input_configuration  += { device: headset              , type: wired   ,\
                                 commonname: headset }
$audio_input_configuration  += { device: headsetforcall       , type: wired   ,\
                                 commonname: headset }
$audio_input_configuration  += { device: headsetforalien      , type: wired   ,\
                                 commonname: headset }
$audio_input_configuration  += { device: bthsp                , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthspforcall         , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: bthspforalien        , type: wireless,\
                                 commonname: bluetoothsco }
$audio_input_configuration  += { device: usbaudio             , type: wired   ,\
                                 commonname: usbaudio }
$audio_input_configuration  += { device: headphoneasfmradiolp , type: wired   ,\
                                 commonname: fmradioloopback }
$audio_input_configuration  += { device: headsetasfmradiolp   , type: wired   ,\
                                 commonname: fmradioloopback }
$audio_input_configuration  += { device: headphoneasfmradio   , type: wired   ,\
                                 commonname: fmradio }
$audio_input_configuration  += { device: headsetasfmradio     , type: wired   ,\
                                 commonname: fmradio }
$audio_input_configuration  += { device: voicecall            , type: builtin ,\
                                 commonname: voicecallrecord }
$audio_input_configuration  += { device: incompatible         , type: builtin ,\
                                 commonname: incompatible }

$privacy = { stage: previous, value: public }
$privacy = { stage: current , value: public }
 
# audio routing
$audio_route  = { type: source, device: microphone, mode: na , hwid: na }
$audio_route += { type: sink  , device: ihf       , mode: ihf, hwid: na }

# volume limits
$volume_limit  = { group: idle       , limit: 100 }
$volume_limit += { group: background , limit: 100 }
$volume_limit += { group: inputsound , limit: 100 }
$volume_limit += { group: systemsound, limit: 100 }
$volume_limit += { group: feedbacksound, limit: 100 }
$volume_limit += { group: event      , limit: 100 }
$volume_limit += { group: othermedia , limit: 100 }
$volume_limit += { group: flash      , limit: 100 }
$volume_limit += { group: player     , limit: 100 }
$volume_limit += { group: game       , limit: 100 }
$volume_limit += { group: alarm      , limit: 100 }
$volume_limit += { group: ringtone   , limit: 100 }
$volume_limit += { group: camera     , limit: 100 }
$volume_limit += { group: videoeditor, limit: 100 }
$volume_limit += { group: call       , limit: 100 }
$volume_limit += { group: aliencall  , limit: 100 }
$volume_limit += { group: navigator  , limit: 100 }
$volume_limit += { group: cstone     , limit: 100 }
$volume_limit += { group: alien      , limit: 100 }
$volume_limit += { group: btnotify   , limit: 100 }
$volume_limit += { group: nonsilent  , limit: 100 }
$volume_limit += { group: alwayson   , limit: 100 }

# audio corking
$audio_cork  = { group: idle       , cork: uncorked }
$audio_cork += { group: background , cork: uncorked }
$audio_cork += { group: systemsound, cork: uncorked }
$audio_cork += { group: feedbacksound, cork: uncorked }
$audio_cork += { group: inputsound , cork: uncorked }
$audio_cork += { group: event      , cork: uncorked }
$audio_cork += { group: alarm      , cork: uncorked }
$audio_cork += { group: othermedia , cork: uncorked }
$audio_cork += { group: flash      , cork: uncorked }
$audio_cork += { group: player     , cork: uncorked }
$audio_cork += { group: game       , cork: uncorked }
$audio_cork += { group: ringtone   , cork: uncorked }
$audio_cork += { group: camera     , cork: uncorked }
$audio_cork += { group: videoeditor, cork: uncorked }
$audio_cork += { group: call       , cork: uncorked }
$audio_cork += { group: aliencall  , cork: uncorked }
$audio_cork += { group: navigator  , cork: uncorked }
$audio_cork += { group: cstone     , cork: uncorked }
$audio_cork += { group: alien      , cork: uncorked }
$audio_cork += { group: btnotify   , cork: uncorked }
$audio_cork += { group: nonsilent  , cork: uncorked }
$audio_cork += { group: alwayson   , cork: uncorked }

# muting
$audio_mute    = { device: microphone           , mute: unmuted }
$audio_mute   += { device: backmicrophone       , mute: unmuted }
$audio_mute   += { device: headmike             , mute: unmuted }
$audio_mute   += { device: headsetforcall       , mute: unmuted }
$audio_mute   += { device: headsetforalien      , mute: unmuted }
$audio_mute   += { device: headset              , mute: unmuted }
$audio_mute   += { device: bthspforcall         , mute: unmuted }
$audio_mute   += { device: bthspforalien        , mute: unmuted }
$audio_mute   += { device: bthsp                , mute: unmuted }
$audio_mute   += { device: tvoutandbthsp        , mute: unmuted }
$audio_mute   += { device: usbaudio             , mute: unmuted }
$audio_mute   += { device: voicecall            , mute: unmuted }
$audio_mute   += { device: fmradio              , mute: unmuted }
$audio_mute   += { device: fmradioloopback      , mute: unmuted }
$audio_mute   += { device: headphoneasfmradiolp , mute: unmuted }
$audio_mute   += { device: headsetasfmradiolp   , mute: unmuted }
$audio_mute   += { device: headphoneasfmradio   , mute: unmuted }
$audio_mute   += { device: headsetasfmradio     , mute: unmuted }

# vibra control
$vibra_mute  = { group: other, mute: unmuted }
$vibra_mute += { group: game , mute: unmuted }
$vibra_mute += { group: ui   , mute: unmuted }
$vibra_mute += { group: event, mute: unmuted }

# backlight control
$backlight   = { state: off }

# currently active (topmost) application pid
$active_application = { pid: 0 }
# alien UI process id
$alien_application = { pid: -1 }

# features
$feature   = { name: fmradio            , allowed: 0        , enabled: 0 }
$feature  += { name: fmradioloopback    , allowed: 0        , enabled: 0 }
$feature  += { name: voicecallrecord    , allowed: 0        , enabled: 0 }
$feature  += { name: bluetoothoverride  , allowed: 0        , enabled: 0 }

# contexts
$context   = { variable: call                   ,  value: inactive }
$context   = { variable: bluetooth_override     ,  value: disabled }  # disabled - active - inactive
$context   = { variable: media_state            ,  value: inactive }  # inactive - background - foreground - active
$context   = { variable: voicecall_record       ,  value: disabled }  # disabled - enabled
#$context   = { variable: call_audio_type,  value: none     }
#$context   = { variable: camera         ,  value: inactive }

# sensors
$proximity = { state: 'unknown' }

# mute state for microphones
$mute  = { default_value: 0, value: 0 }

# override route privacy value to enable public routes during call
$privacy_override = { default_value: default, value: default }

# override audio route from bluetooth to other devices
$bluetooth_override = { default_value: default, value: default }

# enable voicecall recording during phone call
$voicecall_record = { default_value: disabled, value: disabled }

#
# we always need at least one enforcement point
# (workaround for a resolver factstore tracking buglet/feature...)
# 
$enforcement_point = { id: 'ohmd', type: 'internal', name: 'ohmd' }

# policy plugin states, and resolver blocking
$plugin   = { name: 'ohmd', type: 'policy', state: 'ready' }
$resolver = { blocked: 0 }

# internally used variables
$completion_handler_called = { value: no }

all: plugin_check               \
     video_route                \
     update_feature_allowed     \
     audio_route                \
     audio_volume               \
     audio_cork                 \
     audio_mute                 \
     context                    \
     $vibra_mute                \
     $backlight                 \
     $enforcement_point

	if !$resolver:blocked then
	    #echo('*** all ***')
	    $completion_handler_called:value = no
	    resolve(actions, &completion_callback=&completion_callback, \
                    &transaction_id=&transaction_id)
	    #if $completion_handler_called:value == 'no' then
	    #	delay_execution(0, 'completion', &completion_callback, \
	    #    	            &transaction_id, 1)
	    #end
	end

update_feature_allowed:
	# disable fmradio feature when call is starting
	if $context[variable:call]:value != 'inactive' then
		$feature[name:fmradio]:allowed = 0
		$feature[name:fmradioloopback]:allowed = 0
	end

	if $context[variable:call]:value == 'active' || \
	   $context[variable:call]:value == 'outgoing' then
		$feature[name:voicecallrecord]:allowed = 1
	else
		$feature[name:voicecallrecord]:allowed = 0
		$feature[name:voicecallrecord]:enabled = 0

		# fmradio is allowed only when call is not active
		# however, keep allow on during ringtone as well so that
		# enabled state is not reset during incoming call
		if $audio_device_selectable[name:headset]:selectable == 1               || \
		   $audio_device_selectable[name:headsetforcall]:selectable == 1        || \
		   $audio_device_selectable[name:headsetforalien]:selectable == 1       || \
		   $audio_device_selectable[name:headphone]:selectable == 1             || \
		   $audio_device_selectable[name:headphoneforcall]:selectable == 1      || \
		   $audio_device_selectable[name:headphoneforalien]:selectable == 1     || \
		   $audio_device_selectable[name:ihfandheadphone]:selectable == 1       || \
		   $audio_device_selectable[name:ihfandheadset]:selectable == 1         then
			$feature[name:fmradio]:allowed = 1
			$feature[name:fmradioloopback]:allowed = 1
		else
			$feature[name:fmradio]:allowed = 0
			$feature[name:fmradio]:enabled = 0
			$feature[name:fmradioloopback]:allowed = 0
			$feature[name:fmradioloopback]:enabled = 0
		end

	end

	resolve(voicecallrecord_feature_update)
	resolve(fmradioloopback_feature_update)
	resolve(fmradio_feature_update)

voicecallrecord_feature_update: $feature
	if $feature[name:voicecallrecord]:enabled == 1 then
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'voicecall', 1, 1)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'voicecall', 1, 1)
	else
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'voicecall', 0, 0)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'voicecall', 0, 0)
	end

fmradioloopback_feature_update: $feature
	if $feature[name:fmradioloopback]:enabled == 1 then
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradioloopback', 1, 1)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradioloopback', 1, 1)
	else
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradioloopback', 0, 0)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradioloopback', 0, 0)
	end

fmradio_feature_update: $feature
	if $feature[name:fmradio]:enabled == 1 then
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradio', 1, 1)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradio', 1, 1)
	else
		$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
		                                        'fmradio', 0, 0)
		$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
		                                        'fmradio', 0, 0)
	end

feature_request:
	# allow enabling only when allowed is true, disabling is allowed always
	if $feature[name:&feature_name]:allowed == 1 || &value == 0 then
		$feature[name:&feature_name]:enabled = &value
		if &feature_name == 'fmradio'           ||\
		   &feature_name == 'fmradioloopback'   then
				$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
				                                        &feature_name, &value, &value)
				$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
				                                        &feature_name, &value, &value)
		end
		if &feature_name == 'voicecallrecord' then
			resolve(voicecallrecord_feature_update)
			if &value == 1 then
				$voicecall_record:value = 'enabled'
			else
				$voicecall_record:value = $voicecall_record:default_value
			end
		end
		resolve(all)
	end

video_route: $video_device_selectable $gconf
	$video_route = prolog(set_video_routes)

audio_route: $audio_device_selectable $audio_output_configuration \
             $resource_owner $privacy_override $bluetooth_override \
             $current_profile
	$privacy[stage]    |= prolog(set_audio_privacy, previous)
	$audio_route[type] |= prolog(set_audio_routes)
	$privacy[stage]    |= prolog(set_audio_privacy, current)
	# If call is ending and we are going to public route, force release resources
	# Or, if call is ending, and when call was starting route was public, but
	# after call ends route is private, force release resources (use case:
	# listen to music speaker, answer call, plug headset in for the duration of
	# the call, end call with headset connected -> audio stays paused)
	if (($privacy[stage:previous]:value == 'private' ||     \
	        ($audio_resource_owner:previous == 'call' &&    \
	         $audio_resource_owner:current != 'call')) &&   \
	   $privacy[stage:current]:value  == 'public') ||       \
	   ($call_start_privacy:value == 'public' &&            \
	        $audio_resource_owner:previous == 'call' &&     \
	         $audio_resource_owner:current != 'call' &&     \
	   $privacy[stage:current]:value  == 'private')         \
	then
	    #echo('*** stop players ***')
	    $resource_set[manager_id] |= prolog(force_resource_release, \
	                               	        player, player)
	end

audio_volume: $resource_owner $resource_set $volume_limit \
              $current_profile  $audio_route
	$volume_limit[group] |= prolog(set_volume_limits)

audio_cork: $resource_owner $audio_cork
	$audio_cork[group] |= prolog(set_corks)

audio_mute: $mute
	$audio_mute[device] |= prolog(set_mute)

audio_mute_request:
	$mute:value = &mute_state
	resolve(all)

audio_mute_reset:
	$mute:value = $mute:default_value

privacy_override_request:
	$privacy_override:value = &privacy_override_state
	resolve(all)

privacy_override_reset:
	$privacy_override:value = $privacy_override:default_value

bluetooth_override_request:
	if &bluetooth_override_state == 'disconnected' || &bluetooth_override_state == 'default' then
		$bluetooth_override:value = $bluetooth_override:default_value
	else
		$bluetooth_override:value = &bluetooth_override_state
	end
	resolve(all)

reset_bluetooth_override:
	$bluetooth_override:value = $bluetooth_override:default_value

audio_voicecall_record_request:
	if $context[variable:call]:value == 'active' || \
	   $context[variable:call]:value == 'outgoing' then

		if &voicecall == 1 then
			$voicecall_record:value = 'enabled'
		else
			$voicecall_record:value = $voicecall_record:default_value
		end

	end
	resolve(all)

reset_audio_voicecall_record:
	$voicecall_record:value = $voicecall_record:default_value

actions: audio_actions video_actions vibra_actions backlight_actions

audio_actions: $audio_mute $audio_cork $volume_limit $context $audio_route \
               $enforcement_point
	#echo('*** audio_actions ***')
	signal_changed(audio_actions, &completion_callback, &transaction_id, \
	               'com.nokia.policy.context', \
                       'com.nokia.policy.volume_limit', \
                       'com.nokia.policy.audio_route', \
                       'com.nokia.policy.audio_cork', \
		       'com.nokia.policy.audio_mute')
	$completion_handler_called:value = yes

video_actions: $video_route $enforcement_point
	#echo('*** video_actions ***')
	signal_changed(video_actions, '', 0, \
	               'com.nokia.policy.video_route')

vibra_actions: $vibra_mute
	#echo('*** vibra_actions ***')
	signal_changed(vibra_actions, '', 0, \
		       'com.nokia.policy.vibra_mute')

backlight_actions: $backlight
	#echo('*** backlight_actions ***')
	signal_changed(backlight_actions, '', 0, \
		       'com.nokia.policy.backlight')

resource_request:
	echo('*** resource_request: ', &request, ' ', &manager_id)
	$audio_resource_owner:previous = $resource_owner[resource:audio_playback]:owner
	$active_audio_manager_id = prolog(get_active_audio_manager_id)
	$active_audio_manager:previous = $active_audio_manager_id:id
	#echo('$active_audio_manager:previous changes to ', $active_audio_manager:previous)
	$resource_set[manager_id] |= prolog(update_resource_entries)
	$resource_owner[resource] |= prolog(update_resource_owner_entries)
	$audio_resource_owner:current = $resource_owner[resource:audio_playback]:owner
	$active_audio_manager_id = prolog(get_active_audio_manager_id)
	$active_audio_manager:current = $active_audio_manager_id:id
	#echo('$active_audio_manager:current changes to ', $active_audio_manager:current)

	# If active manager_id changes release the previous active playback, so that when the
	# new player pauses, previously active playback won't continue.
	if $active_audio_manager:previous != 0 &&                               \
	   $active_audio_manager:current != 0 &&                                \
	       ($audio_resource_owner:previous == 'player' ||                   \
	        $audio_resource_owner:previous == 'game') &&                    \
	   $audio_resource_owner:previous == $audio_resource_owner:current &&   \
	   $active_audio_manager:previous != $active_audio_manager:current      \
	   then
	    #echo('*** force_resource_release_one ', $active_audio_manager:previous)
	    $resource_set[manager_id] |= prolog(force_resource_release_one, $active_audio_manager:previous)
	end

	resolve(all)


accessory_request:
	$audio_device_accessible[name] = prolog(update_accessible_audio_entry,\
	                                        &accessory_name, \
					        &accessory_driver, \
					        &accessory_connected)
	$audio_device_selectable[name] = prolog(update_selectable_audio_entry,\
	                                        &accessory_name, \
						&accessory_driver, \
						&accessory_connected)
	$video_device_accessible[name] = prolog(update_accessible_video_entry,\
	                                        &accessory_name, \
						&accessory_connected)
	$video_device_selectable[name] = prolog(update_selectable_video_entry,\
	                                        &accessory_name, \
						&accessory_connected)
	resolve(all, '', 0)

update_accessory_mode:
	$audio_output_configuration[device] |= prolog(update_accessory_mode, \
					 	      &accessory_name,       \
						      &accessory_mode)

telephony_request:
	$call_action = prolog(call_request, &call_id, &call_state)

telephony_audio_update:

#
# application_request
#
active_ui_change_request:
	echo('*** active_ui_change_request appwin=', &appwin, \
                  ' pid=', &pid , ' iconize=', &iconize, ' ***')

# Bluetooth HSP state machine hooks

# Bluetooth HSP goes from connected to playing state

bthsp_start_audio:
	$audio_output_configuration[device:bthsp]:hwid = &hwid
	$audio_output_configuration[device:bthspforcall]:hwid = &hwid
	$audio_output_configuration[device:ihfandbthsp]:hwid = &hwid
	$audio_output_configuration[device:tvoutandbthsp]:hwid = &hwid

# Bluetooth HSP goes from playing to connected state, check if we should
# set up the bluetooth override (transfer audio back to device).

bthsp_stop_audio:
	# echo('bthsp_stop_audio')

bthsp_disconnect:
	# unset the HSP/HFP flag
	$audio_output_configuration[device:bthsp]:hwid = na
	$audio_output_configuration[device:bthspforcall]:hwid = na
	$audio_output_configuration[device:ihfandbthsp]:hwid = na
	$audio_output_configuration[device:tvoutandbthsp]:hwid = na

bthsp_connect:



# first call hook
telephony_first_call_hook: audio_mute_reset privacy_override_reset reset_bluetooth_override
	#$mode[foo] = prolog(update_mode, telephony)
	if $call_start_privacy:value == 'none' \
	then
	    $call_start_privacy:value = $privacy[stage:current]:value
	end

# last call hook
telephony_last_call_hook: audio_mute_reset privacy_override_reset reset_bluetooth_override reset_audio_voicecall_record
	#$mode[foo] = prolog(update_mode)
	# resolve(all, '', 0)
	$call_start_privacy:value = none

# call start hook: workaround for tonegen bad audio quality at call start
telephony_call_start_hook:

# local hungup hook
telephony_local_hungup_hook:

# call end hook
telephony_call_end_hook:

# call connect hook (call locally accepted)
telephony_call_connect_hook:

# call onhold hook
telephony_call_onhold_hook:

# call offhold hook
telephony_call_offhold_hook:

# call active hook (call remotely accepted)
telephony_call_active_hook:

# dialstring sending started
telephony_sending_dialstring:

# dialstring sending stopped
telephony_stopped_dialstring:

active_application_request:
	$active_application:pid = &pid

alien_application_request:
	$alien_application:pid = &pid

# context variables:
# call                  - com.nokia.policy.call ($call) changes
# bluetooth_override    - com.nokia.policy.bluetooth_override ($bluetooth_override) changes
# media_state           - com.nokia.policy.media_state
context: $voicecall_record $bluetooth_override $active_application \
         $alien_application $resource_set
	$context[variable] |= prolog(update_contexts)

# block resolving if any policy plugin is not ready
plugin_check: $plugin
	if $plugin[type:policy, state:!ready] then
	    $resolver:blocked = 1
	else
	    $resolver:blocked = 0
	end

# forcibly intern 'rule' (alias for 'prolog') into the symbol table
__alias_prolog:
	rule(foo, bar)
